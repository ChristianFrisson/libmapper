% Roadmap for libmapper

This document contains information on what needs to be accomplished in
the library before a first release, and thereafter what features might
be added in the future.

Requirements
============

Before initial release, the library must provide the following:

* Allow defining a named device and input/output signals.

* Allow allocation of a unique port and name for the device.

* Allow automatically responding to GUI commands to set up routings
  and mappings.

* Allow monitoring of the network and querying of this information for
  display and user interaction.

Current Status
==============

The current status is summarized here:

* Name/port allocation works.

* A device and signal API is established, allowing polling of the
  network, responding to incoming signal values, and updating
  registered output signals.

* Routings (called Links) and Mappings can be established, and all
  required signal conditioning functions have been implemented.

* A device is able to also monitor the network and store information
  about other devices, signals, links, and mappings, and this
  information can be queried.

Tasks To Do
===========

Target release date: November 15, 2010.

The following tasks currently need to be accomplished before initial
release:

* Code review of the database API. 
    * Check clarity, as it is somewhat cluttered and verbose with various 
      query types.
    * Extensible attributes of signals and devices. Effect on database
      API?  Perhaps using string-based names of attributes can
      simplify the API. (Steve, 1 week)

* Should input/output be a simple parameter of signals, or specified
  at creation time? Means changing protocol. (Yes. Joe & Steve. 1 week)

* Create a concise but convincing example for both controller and
  synth sides.  Optional support for audio output, perhaps using RtAudio,
  would be beneficial here. (Steve)

* Develop the SWIG bindings, tested at least against Python.  In fact
  there would be several benefits to doing this with higher priority,
  as it would help in developing examples.  For sources and destinations,
  it would provide a cross-platform GUI (tkinter).  It would also ease
  the development of testmonitor as a barebones example of a network
  monitor/UI (see the previous point), by providing GUI and/or ncurses
  bindings. (Steve, 2 weeks)

* Include some Max/MSP standalone versions of controllers, Granul8,
  etc? (Joe)

* Are we including the Max/MSP GUI, standalone? Check licenses, size,
  etc. Binary release for Mac OS X.  (Joe)

* Documentation, tutorials. External API. (Steve) Textual
  tutorial. (Vijay)

Lower priority tasks
====================

* Ensure correct action is taken (if any) when signals are registered
  and unregistered, or devices disappear and reappear. (Depends on
  namespace hashing, save for later.)

* Implement namespace hashing.

* Implement connection muting. (Joe)

* Implement OSC aliasing for signal connections.

* Implement bidirectional communication for state queries.

* Implement allocation "suggestions" to speed up port/ordinal
  allocation.

* Add "fixed" processing type.

* Port to Windows.

* Add a user interaction to "testmonitor", allowing users to create
  connections in a text-based environment.  Although there will be
  graphical interfaces, described in the next section, it should be
  considered useful for the library to come with a simple tool to
  monitor and possibly control the network, so that a user may test
  the examples.

* Look into usage on embedded platforms. (Works on gumstix!)

* In support of the previous point, implement the proposal for
  pre-defined expressions.

* Consider using a back-end such as SQLite for database searching.
  (May be more efficient for supporting large networks.)

External tasks
==============

There are some tasks which address uses of the library/protocol rather
than being tasks for the library development itself.

* Development of Max external. (Done)

* Development of Pure Data external. (Joe)

* Development of SuperCollider usage, either using library or
  reimplemented in SC to some extent.

* Development of Qt GUI. (In progress.)

* Development of browser-based GUI.

* Modify some of the FAUST architectures (e.g., Jack) to automatically
  create a libmapper interface for input and output signals.

* Wrap all STK instruments as mapper-compatible synths.

Future developments
===================

Ideas that we consider to have potential but are not being considered
for current work.

* Audio-rate signal connections via Jack, SoundFlower, etc.

* Interpolation for filtering of sporadic signals

* Many-to-one mapping.
